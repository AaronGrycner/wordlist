#include "WordGen.h"

string WordGen::next_word()
{
	string word;

	word = its->get_word();

	return word;
}

WordGen::WordGen(vector<vector<string>> dict, string m, int chunk) : dictionary(dict), mask(m)
{
	get_parsed_vec();

	try {
		check_valid_entry();
	}
	catch (Exception e) {
		throw e;
	}

	its = new Iterators(dictionary, format_vec, chunk);
}

// RULES FOR FORMAT PARSING
// 
// prefix with number 1 - 9 = number of unique words
// @ = sequence of letters that form words
// $ = symbols
// ! = numbers
// 
// ex. format string = 2@@@@@!
// vector |2|null|null|null|null|null| ! | $ |
//         @x5
//
// this indicates there is a two word string five letters long with an ending number and symbol

void WordGen::get_parsed_vec()
{
	int str_index{};  // indicates where a multi word string begins

	// this portion accounts for the extra spaces generated by the prefixes by deleting the '@'
	// immediately following the prefix
	for (string::iterator it = mask.begin(); it != mask.end(); ++it) {
		if (*it != '@' && *it != '!' && *it != '$') {
			mask.erase(it+1);
		}
	}

	format_vec.resize(mask.length());

	char c{};
	for (int i{}; i < mask.size(); ++i) {
		c = mask[i];

		switch (c) {
		case '@':
			format_vec[str_index].push_back('@');
			break;
		case '$':
			format_vec[i].push_back('$');
			break;
		case '!':
			format_vec[i].push_back('!');
			break;
		default:
			format_vec[i].push_back(c);
			str_index = i;
			break;
		}
	}
}

void WordGen::check_valid_entry()
{
	for (auto elem : format_vec) {

		if (!elem.empty()) {
			auto x{ elem[0] - '0' };

			if (elem.at(0) != '$' && elem.at(0) != '!') {
				if (x > elem.size()) {
					throw InvalidWordFormat();
				}
			}
		}
	}
}